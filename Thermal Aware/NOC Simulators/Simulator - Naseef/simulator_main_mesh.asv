clc;
clear all;

% Global Simulation numbers
global MsgLength; % Number of flits in messages
MsgLength = 64;
global MaxNumberOfVC; % maximum number of VCs in all ports
MaxNumberOfVC = 8;
global CoreBufferDepth;
CoreBufferDepth = 16;
%Naseef Mansoor 13 Jan 2013 code changes for running multiple traffics. The
%only change being made is the 
global UniformRandom; % value = 1
UniformRandom=1;
global HotSpot; % value = 2
HotSpot=2;
global HotSpotCore;
HotSpotCore=9;
global Transpose;%value = 3
Transpose=3;
global FFTDist;%value = 4
FFTDist=4;
global MaxCoreNumber;
MaxCoreNumber = 64;

global NoWirelessTranscievers ;
NoWirelessTranscievers = 7;
% p = [0.3 0.4 0.5 0.6 0.7 0.8 0.9 1];
traffic = HotSpot;
global MaxPortNumber;
% MaxPortNumber = 5;
global OutputBufferDepth; % max depth of output VCs
OutputBufferDepth = 16;
global MaxVCNumberOutput;
MaxVCNumberOutput = 8;
global MaxOutputVCNumber;
MaxOutputVCNumber = 8;

global MaxSwitchNumber; % maximum number of switches determined by topology
MaxSwitchNumber = 64;

global BufferDepth; % maximum depth of VC buffers
BufferDepth = 16;
global RoutingType; % value denotes type of routing adopted
RoutingType = 3;
global Mesh; % routing type of Mesh
Mesh = 1;
global DijkstraRouting;
DijkstraRouting = 3; % value = 3
global TileDimension;
TileDimension = [8 8]; % tile dimension in a mesh
global TileSize;
TileSize=[20 20];
global XDim; % 1
XDim = 1;
global YDim; % 2
YDim = 2;
global NumberOfFlitsAbsorbed; % counting the number of flits absorbed by all receiving cores
global NumberOfFlitsGenerated; % counting the number of flits injected by all sending cores
global NumberOfCyclesForThroughput; % counting the number of cycles after reseting (used for calculating the throughput)
global ResetCycle; %

%ResetCycle =2000;
ResetCycle =500;
global NumberOfSimulationCycles; % number of cycles the simulator is run


%NumberOfSimulationCycles = 5000;
NumberOfSimulationCycles = 5000;


global MulticastSource1;
MulticastSource1 = 1;
global MulticastSource2;
MulticastSource2 = 2;
global MulticastSource3;
MulticastSource3 = 3;
global MulticastSource4;
MulticastSource4 = 4;
global MulticastSource5;
MulticastSource5 = 5;
global MulticastSource6;
MulticastSource6 = 6;

global MulticastDestination1;
MulticastDestination1 = 1;
global MulticastDestination2;
MulticastDestination2 = 2;
global MulticastDestination3;
MulticastDestination3 = 3;
global MulticastDestination4;
MulticastDestination4 = 4;
global MulticastDestination5;
MulticastDestination5 = 5;
global MulticastDestination6;
MulticastDestination6 = 6;

global MulticastSource;
MulticastSource = [8 9 14 32 33 61 64];


% global p;
% p=0;

% Data Structure indices of CoreStatus (values: 1,2,3,4)
% 2D array
% row denoted by CoreNumber

global OnOrOff; % value = 1
OnOrOff = 1;

% the following variables are used depending on the number of message
% generated by each core - example for unicast only CurrentMsgNumber is
% used wheras for multicast with six messages all the variables are used
global CurrentMsgNumber; % value = 2
CurrentMsgNumber = 2;
global CurrentMsgNumber2; % value = 3
CurrentMsgNumber2 = 3;
global CurrentMsgNumber3; % value = 4
CurrentMsgNumber3 = 4;
global CurrentMsgNumber4; % value = 5
CurrentMsgNumber4 = 5;
global CurrentMsgNumber5; % value = 6
CurrentMsgNumber5 = 6;
global CurrentMsgNumber6; % value = 7
CurrentMsgNumber6 = 7;


% Wade Campney
% Added #7 for current buffer direction to track which direction a message
% is currently going when going through the link buffers
% Also added #8 & #9 for new more accurate energy calculations


% Data Structure indices for MsgStatus
% 2D array
% row denoted by MsgNumber
global VCNumber; % value = 1
VCNumber = 1;
global FlitsLeft; % value = 2
FlitsLeft = 2;
global Source; % value = 3
Source = 3;
global Destination; % value = 4
Destination = 4;
global InjectCycle; % value = 5
InjectCycle = 5;
global AbsorbCycle; % value = 6
AbsorbCycle = 6;
global CurrentBufferDirection; % value = 7
CurrentBufferDirection = 7;
global SwitchCycles;
SwitchCycles = 8;
global BufferCycles;
BufferCycles = 9;

% % % % % % % % % % % % % % % % % % % % % % % % % % % ENERGY CALCULATION

%Header Flit Number as it is the first flit in a message
global HeaderFlit;
HeaderFlit =1;

% Data structure for energy calculations
%stores the energy comsumed for each flit in each message
global MsgEnergyStatus;
%3D array
%1D Message Number
%2D Flit Number of each message
%3D mentioned below
global FlitInjectCycle;  % to track each flit's inject cycle
FlitInjectCycle =1;

global FlitAbsorbCycle;  % to track each flits absorbtion cycle at the final destination
FlitAbsorbCycle =2;

global FlitEnergy ;      % energy calculated for each flit traversal
FlitEnergy =3;

% Data structure for link energy calculations
global LinkEnergyMatrix;
% 2D array
% 1D Source
% 2D Destination

% Data structure for link energy calculations

global LinkCycleMatrix
% 2D array
% 1D Source
% 2D Destination

global SimCycle;

% struture of InputVCBufferStatus
% 4D array
% 1st dimension denoted by switch number
% 2nd dimension denoted by port number of the switch
% 3rd dimension denoted by VC number
global MsgNumberInVC; % value = 1, contains the number of the message currently occupying the VC, reserved for a single message until all flits pass
global FlitsPassedFromVC; % value = 2, contains the number of flits of MsgNumber passed from the VC
global NextPortNumber; % value = 3,contains the next port number for the flit
global NextVCNumber; % value = 4, contains the next port's VC number for the flit
global NumberOfFreeFIFO; % value = 5, initialized to BufferDepth
MsgNumberInVC = 1;
FlitsPassedFromVC = 2;
NextPortNumber = 3;
NextVCNumber = 4;
NumberOfFreeFIFO = 5;

% Data Structure indices for CoreBufferStatus
% 2D array
% row denoted by CoreNumber
% 2nd dimension by VCNumber (1 to MaxNumberOfVC)

% Structure of AbsorbArbitStatus
% 2D array: contains the number of the VC last serviced for flit absorption
% 1st dimension addressed by core/switch number
% 2nd dimension by port number: which is always 1 for ports to the core
% structure maintained same as InputVCBufferStatus to reuse the
% input_arbitrate funtion

% structure of OutputVCBufferStatus
% 4D array
% 1st dimension denoted by switch number
% 2nd dimension denoted by port number of the switch
% 3rd dimension denoted by VC number
% global MsgNumberInVC; % value = 1, contains the number of the message currently occupying the VC, reserved for a single message until all flits pass
global NumberOfFreeFIFOOutput; % value = 2, contains the number of free FIFOs in the output VC
global FlitsPassedFromVCOutput; % value = 3, contains the number of flits passed from this virtual channel (not needed in this function; needed for inter-move)
% global NextVCNumber; % value = 4, contains the next port's VC number for the flit
% MsgNumberInVC = 1;
NumberOfFreeFIFOOutput = 2;
FlitsPassedFromVCOutput = 3;
% NextVCNumber = 4;


% Wade Campney
global NumberWirelessNodes;
NumberWirelessNodes = 13;


% New data structure for information pertaining to wireless nodes/token
% Structure of WiNodes

% 1 contains the switches that have wireless
% 2 is the port of the switch that is wireless
% 3 contains the status of the token, if 1, then the switch has the token,
% only one switch can have it at a time
% 4 is the VC being serviced, once empty, the token is passed ( or the
% number of flits sent maybe, not sure what will be needed yet)
% 5 is the node currently being sent to if it has the token
% 6 is the number of flits sent this token possession
% 7 is the total number of flits sent wirelessly
% 8 is the number of cycles the switch has had the token

% added 9-10 for servicing all VCs on all ports before passing the token

% 9 is the number of ports served this token possession
% 10 is the number of VCs served this token possession



% Change back to 8, changed to 10 to test token
global WiNodes;
WiNodes = zeros(NumberWirelessNodes,10);

% initialize token
WiNodes(1,3) = 1; 

% Wade Campney
% Structure of ThroughputPerCycle
% 2D array containing the throughput for each simulation cycle
% 1st dimension is the cycle number
% 1 is the number of flits absorbed
% 2 is the actual throughput for that cycle

global ThroughputPerCycle;
ThroughputPerCycle = zeros(NumberOfSimulationCycles,2);


% structure of Connectivity
% 3D array with switch number on both dimensions (row sender and column
% receiver)
% contains the number of cycles needed by each link between switches,
% sending and receiving port numbers as well
% default 0 for no link
global Connectivity; % the array
global LinkCycle; % value = 1, contains number of cycles taken by link for flit traversal
LinkCycle = 1;
global SendPort; % value = 2, contains the number of the port of sending switch
SendPort = 2;
global RecvPort; % value = 3, contains number of the port of the receiving switch
RecvPort = 3;

Connectivity = zeros(MaxSwitchNumber,MaxSwitchNumber,RecvPort); % init

%naseef mansoor
% define a connectivity matrix to temporarily store this current connectivity matrix 
ConnectivityTemp=Connectivity;
% Define a global variable to store if a Message will follow the wired
% dikstra or wireless dikstra
% MsgRoutingScheme 1D marics to store which message will be routed via the
% wired path and which one via the wireless path.
%if value= 1 then wired path routing
%if value= 2 then wireless path routing
global MsgRoutingScheme;
MsgRoutingScheme=[];
%declare a threshold variable such that if probability for a msg is greater
%than this variable it will use the wireless topology else it will use the
%wired topology
global WirelessRoutingThreshold;
WirelessRoutingThreshold=.96;
%naseef mansoor end

%Naseef Mansoor
global TokenPassingBlockCycle;
TokenPassingBlockCycle = 1000;
% If node is able to transmit then EnabledWirelessDataTransmission=1
global EnabledWirelessDataTransmission;
EnabledWirelessDataTransmission=1;

% Set to 1 if simualtion should not ever block the token passing
global DoNotBlockToken;
DoNotBlockToken = 0;
%naseef mansoor end

% Naseef Mansoor on 11 Jan 2013 for systems with multiple token
% This change is made to generate multiple tokens in the system
% In this case we will have multiple WI's transmitting but no effective message is received. So their output
% buffer depth is updated but not the receiver input buffer depth.
% Config: EnabledWirelessDataTransmission=1 DoNotBlockToken=0
% GenerateMultipleToken=1. The cycle where token will be regeenrated is the
% TokenPassingBlockCycle.
global GenerateMultipleToken;
GenerateMultipleToken=1;
global DuplicateTokenGenerationCycle;
DuplicateTokenGenerationCycle=TokenPassingBlockCycle;
%naseef mansoor end

% Wade Campney
% Change between excel test files

%Connectivity( :, :,1) = xlsread('WiNoc_singlelink_test.xls');
%Connectivity( :, :,1) = xlsread('64_core_wired.xls');
%Connectivity( :, :,1) = xlsread('WiNoCTest_12WI.xls');
Connectivity( :, :,1) = xlsread('WiNoCTest_13WI.xls');

PortNumberTemp = 5*ones(MaxSwitchNumber,1); % mesh topology

temp1=Connectivity( :, :,1);
temp2=zeros(MaxSwitchNumber,MaxSwitchNumber);
wirelessCount = 1;
foundWireless = 0;

% Generates the port numbers in which other SW is connected
for i=1:MaxSwitchNumber
    PortCount=2;
    foundWireless = 0;
    for j=1:MaxSwitchNumber
        if(temp1(i,j)==1)
            temp2(i,j)=PortCount;
            PortCount=PortCount+1;
        elseif(temp1(i,j) == 2)
            % wireless node
            temp2(i,j)=PortCount;
            PortCount=PortCount+1;
            if(wirelessCount <= NumberWirelessNodes)
                if(WiNodes(wirelessCount,1) == 0) % WiNodes is empty
                    if(wirelessCount == 1)% first enrty for WiNodes
                        WiNodes(wirelessCount,1) = i;
                        WiNodes(wirelessCount + 1,1) = j;
                        
                        wirelessCount = wirelessCount + 2;
                    else
                        WiNodes(wirelessCount,1) = j;
                        wirelessCount = wirelessCount + 1;
                    end
                end
            end
            Connectivity(i,j,1) = 1;
        else

        end
        
    end
    PortNumberTemp(i) = PortCount - 1;
end


Connectivity( :, :,2) = temp2; % temp2 has the port number in which i is connected to j
Connectivity( :, :,3) = Connectivity( :, :,2)';


% Wade Campney
% Inserted creation of new data structures here


% Structure of LinkData
% contains the distance of the links between the switches
% row sender and column receiver (sender,receiver,#)
global LinkDistance;
LinkDistance = 1; % contains the actual distance
global NumBuff;
NumBuff = 2; % contains the number of buffers on the link
global NextJump;
NextJump = 3; % contains the number of the buffer for the next jump on
% the link

global LinkData;

LinkData = zeros(MaxSwitchNumber,MaxSwitchNumber,NextJump);

% structure of SBConnectivity(SwitchBufferConnectivity)
% 3D array with switch number on both dimensions (row sender and column
% receiver)

% value = 1, contains number of cycles taken by link for flit traversal
LinkCycle = 1;
% value = 2, contains the number of the port of sending switch
SendPort = 2;
% value = 3, contains number of the port of the receiving switch
RecvPort = 3;

global SBConnectivity;


% Structure of SwitchConn
% 1st dimension contains  switch number that the buffer sends to
% 2nd contains the lower numbered switch for a one buffer situation
% 3rd contains the higher numbered switch for a one buffer situation

global SwitchRecvPort; % value = 1; contains the number of the port of the receiving switch
SwitchRecvPort = 1;
global LowerBuff;  % value = 2; contains the number of the port the buffer sends out of
LowerBuff = 2;
global HigherBuff;  % value = 3; contains the number of the switch the buffer sends to
HigherBuff = 3;

global SwitchConn;



%Connectivity(:,:,1) = xlsread('test_wired.xlsx');
LinkData(:,:,1) = xlsread('64core_Link_Distance.xls');

% Calculate the number of buffers on each link and the total number of
% buffers to populate LinkData(:,:,2)

global TotalLinkBuffers;

TotalLinkBuffers = 0;

% for i=1:MaxSwitchNumber
%     
%     for j=1:MaxSwitchNumber
%         
%         if(LinkData(i,j,1) ~= -1)
%             TempNumBuffers = round((LinkData(i,j,1)/2) - 1);
%             LinkData(i,j,2) = TempNumBuffers;
%             TotalLinkBuffers = TotalLinkBuffers + TempNumBuffers;
%         else
%             LinkData(i,j,2) = -1;
%         end
%     end
% end

% As total buffer is recomputed for both link direction i to j and j to i
% so divide by 2.
TotalLinkBuffers = TotalLinkBuffers/2;

global SwitchTotal;

SwitchTotal = MaxSwitchNumber + TotalLinkBuffers;


% initialization of SwitchConn and SBConnectivity after the total number of
% buffers on the links was calculated

SwitchConn = zeros(TotalLinkBuffers,3);
SBConnectivity = zeros(TotalLinkBuffers,TotalLinkBuffers,3);

% Populate LinkData(:,:,3) with the next jumps

CurrentBuff = MaxSwitchNumber + 1;

for i=1:MaxSwitchNumber
    
    for j=i:MaxSwitchNumber
        
        if(LinkData(i,j,2) > 0)
            LinkData(i,j,3) = CurrentBuff;
            LinkData(j,i,3) = CurrentBuff + LinkData(i,j,2) - 1;
            CurrentBuff = CurrentBuff + LinkData(i,j,2);
        else
            LinkData(i,j,3) = -1;
            LinkData(j,i,3) = -1;
        end
    end
end

% Populate SBConnectivity with the sending and receiving ports for the buffers

for i=1:MaxSwitchNumber
    
    for j=i:MaxSwitchNumber
        temp = LinkData(i,j,3);
        if(temp > 0)
            % Switch i sends to buffer temp on port 2
            SBConnectivity(i,temp,2) = Connectivity(i,j,2);
            SBConnectivity(temp,i,2) = 2;
            while(temp < LinkData(j,i,3))
                % temp sends to the next buffer on 3 and receives on 2
                SBConnectivity(temp,temp+1,2) = 3;
                
                SBConnectivity(temp+1,temp,2) = 2;
                temp = temp + 1;
            end
            
            SBConnectivity(temp,j,2) = 3;
            SBConnectivity(j,temp,2) = Connectivity(j,i,2);
        end
    end
end

% Wade Campney
% Combining Connectivity into SBConnectivity so it will contain
% all the necessary information

for i=1:MaxSwitchNumber
    
    for j=1:MaxSwitchNumber
        
        if(LinkData(i,j,3) == -1)
            SBConnectivity(i,j,2) = Connectivity(i,j,2);
        end
    end
end

SBConnectivity(:,:,3) = SBConnectivity(:,:,2)';

% setting up SBConnectivity(:,:,1)

for i=1:SwitchTotal
    
    for j=1:SwitchTotal
        if(SBConnectivity(i,j,2) == 0)
            SBConnectivity(i,j,1) = -1;
        else
            SBConnectivity(i,j,1) = 1;
        end
    end
    
end

% Populating SwitchConn with the port number for the switch connected to
% the buffer

% If there is only one buffer inbetwen the switches, need to just use
% Connectivity to chose the necessary port.

for i=1:MaxSwitchNumber
    
    for j=i:MaxSwitchNumber
        tempSend1 = LinkData(i,j,3);
        tempSend2 = LinkData(j,i,3);
        
        if(tempSend1 > 0)
            if(tempSend1 == tempSend2)
                % Special case of only one buffer
                SwitchConn(tempSend1,1) = -1;
                SwitchConn(tempSend1,2) = i;
                SwitchConn(tempSend1,3) = j;
            else
                SwitchConn(tempSend1,1) = i;                
                SwitchConn(tempSend2,1) = j;
            end
        end
    end
end


% structure of PortNumber
% 1D array
% 1st dimension denoted by switch number
% contains the nummber of ports for a particular switch, formed depending
% upon topology, can be globally defined

global PortNumber;
PortNumber = 5*ones(SwitchTotal,1); % mesh topology

PortNumber(1:64) = PortNumberTemp;

% Filling in the rest of PortNumber for all of the buffer switches

for i = 65:SwitchTotal
    
    if(i > MaxSwitchNumber)
        count = 3;
    else
        count = 1;
        for j = 1:MaxSwitchNumber
            if (Connectivity(i,j,LinkCycle) ~= -1)
                count = count + 1;
            end
        end
    end
    
    PortNumber(i) = count;
    
end

% WirelessPortArbitStatus Structure
% 
% 1 is the port 
% 2 is the VC
% 3 is the switch

global WirelessPortArbitStatus;
WirelessPortArbitStatus = zeros(NumberWirelessNodes,3);

% Wade Campney
% My changes end here


MaxPortNumber = max(PortNumber);

% structure of LinkArbitStatus
% 2D array
% 1st dimension denoted by Switch Number
% 2nd dimension denoted by port number
% contains the number of the VC last served

% structure of LinkStatus
% 3D array
% 1st dimension: sending switch number
% 2nd dimension: receiving switch number
global SendCycle; % value = 1; contains the cycle of the SimCycle lst flit was sent in
global RecvCycle; % value = 2; contains the cycle of SimCycle lst flit was received in on this link
global SourceVC; % value = 3; contains the VC number at source port/switch currently
global DestinationVC; % value = 4, contains the destination VC number at destination port/switch
global MsgNumber; % value = 5, contains the msg number of the flit in transit
SendCycle = 1;
RecvCycle = 2;
SourceVC = 3;
DestinationVC = 4;
MsgNumber = 5;

% structure of DijkstraRoutingMatrix
% 3D array with switch number on both dimensions (row sender and column
% receiver)
% contains the shortest path routing for each combination of source and
% destination

global DijkstraRoutingMatrix;

%Naseef Mansoor
% Define two new matrics to have dijkstra routing information of both wired
% and wireless network
global DijkstraRoutingMatrixWired;
global DijkstraRoutingMatrixWireless;
%Naseef Mansoor End

DijkstraRoutingMatrix = zeros(MaxSwitchNumber,MaxSwitchNumber,MaxSwitchNumber);
[ DijkstraRoutingMatrix ] = dijkstra_routing_information( DijkstraRoutingMatrix );

%Naseef Mansoor
% Save this wireless routing matrics
DijkstraRoutingMatrixWireless = DijkstraRoutingMatrix;
% Save wireless connectivity matrix
ConnectivityTemp=Connectivity;
%Update the connectivity to the wired topology excel
Connectivity( :, :,1) = xlsread('64_core_wired.xls');
Connectivity( :, :,2) = xlsread('64core_Link_Distance.xls');
Connectivity( :, :,3) = Connectivity( :, :,2)';

% Recalculate the routes for the wired topology. Notice we have chnaged the
% connectivity. We need to clear the current dijkstra matrics
DijkstraRoutingMatrix = zeros(MaxSwitchNumber,MaxSwitchNumber,MaxSwitchNumber);
[ DijkstraRoutingMatrix ] = dijkstra_routing_information( DijkstraRoutingMatrix );
% save the wired routing matrics
DijkstraRoutingMatrixWired = DijkstraRoutingMatrix;
% Now swap back to the wireless connectivity matrics
ConnectivityWired=Connectivity;
Connectivity = ConnectivityTemp;
% Restore the dijkstra to wireless routing(default)
DijkstraRoutingMatrix=DijkstraRoutingMatrixWireless;
%Naseef Mansoor End

% Wade Campney
% Modified LinkStatus, InputVCBufferStatus, & OutputVCBufferStatus to be
% large enough to support the link buffers as well (#s after
% MaxSwitchNumber are buffers), also LinkArbitStatus?!?

% for i = 1:8
% Initialization
InjectionLoad = 1; %p(i);
NumberOfFlitsAbsorbed = 0;
NumberOfFlitsGenerated = 0;
NumberOfCyclesForThroughput = 0;

InputVCBufferStatus = zeros(SwitchTotal,MaxPortNumber, MaxNumberOfVC, NumberOfFreeFIFO);
InputVCBufferStatus ( :, :, :, NumberOfFreeFIFO ) = BufferDepth;

OutputVCBufferStatus = zeros(SwitchTotal,MaxPortNumber,MaxVCNumberOutput,NextVCNumber); % assumed 5 ports for a mesh switch
OutputVCBufferStatus( :, :, :,NumberOfFreeFIFOOutput) = OutputBufferDepth;

CoreStatus = zeros(MaxCoreNumber,CurrentMsgNumber6);
CoreBufferStatus = CoreBufferDepth*ones(SwitchTotal,MaxNumberOfVC);
MsgStatus = zeros(1,BufferCycles); % init with 1 dummy message.
AbsorbArbitStatus = zeros(SwitchTotal,1);

LinkArbitStatus = zeros(SwitchTotal, MaxPortNumber);
LinkStatus = zeros(SwitchTotal, SwitchTotal, MsgNumber);
InputArbitStatus = zeros(SwitchTotal, MaxPortNumber);
OutputArbitStatus = zeros(SwitchTotal, MaxPortNumber);
PortArbitStatus = zeros(SwitchTotal, 1);
VirtualArbitStatus = zeros(SwitchTotal,MaxPortNumber);
VcArbitStatus = zeros(SwitchTotal,MaxPortNumber);



MsgEnergyStatus=zeros(1,MsgLength,FlitEnergy);

LinkEnergyMatrix=zeros(MaxCoreNumber,MaxCoreNumber);
LinkCycleMatrix=zeros(MaxCoreNumber,MaxCoreNumber);



% average hop count calculation
hop=0;
avghop=0;
for SourceLink = 1:MaxCoreNumber
    for DestinationLink = 1:MaxCoreNumber
        if(SourceLink ~= DestinationLink)
            hop=hop+ nnz(DijkstraRoutingMatrix(SourceLink,DestinationLink,:));
        end
    end
end
avghop=hop/(MaxCoreNumber*(MaxCoreNumber-1))



% ------------------------------------------------------------------------%
% Simulated Annealing test section

%  NumberWirelessNodes = 13;
% 
%  global WiNodes;
%  WiNodes = zeros(NumberWirelessNodes,1);
% 
% 
% WiNodes(1) = randi(MaxCoreNumber,1);
% 
% 
% for i = 2:NumberWirelessNodes
%     done = 0;
% 
%     while(done == 0)
%         % generate next random node
%         nextNode = randi(64,1);
% 
% 
%         % check to see if that node already exists
%         exists = 0;
% 
%         for j = 1:NumberWirelessNodes
%             if(nextNode == WiNodes(j))
%                 exists = 1;
%             end
%         end
% 
%         correctDist = 0;
% 
%         if(exists == 0)
%             % check to see if the node is within 7mm of any other nodes;
%             correctDist = 1;
% 
%             for j = 1:NumberWirelessNodes
%                 otherNode = WiNodes(j);
% 
%                 if(otherNode ~= 0)
%                     distance = distanceCalc(nextNode,otherNode);
% 
%                     if(distance < 7)
%                         correcDist = 0;
%                     end
%                 end
% 
%             end
% 
%         end
% 
%         alreadyLinked = 0;
% 
%         if(correctDist == 1)
% 
%             for j = 1:NumberWirelessNodes
%                 otherNode = WiNodes(j);
% 
%                 if(otherNode ~= 0)
% 
%                     if(Connectivity(otherNode,nextNode) == 1)
%                         alreadyLinked = 1;
%                     end
%                 end
%             end
% 
%         end
% 
%         if(alreadyLinked == 0 && correctDist == 1 && exists == 0)
%             WiNodes(i) = nextNode;
%             done = 1;
% 
%         end
%     end
% end
% 
% 
% % Setting up Connectivity matrix to include the wireless links
% 
% for i = 1:NumberWirelessNodes
% 
%     CurrentNode = WiNodes(i);
% 
%     for j = 1:NumberWirelessNodes
% 
%         tempNode = WiNodes(j);
% 
%         if(tempNode ~= CurrentNode)
%             Connectivity(tempNode,CurrentNode,1) = 1;
%             Connectivity(CurrentNode,tempNode,1) = 1;
%         end
%     end
% 
% end
% 
% 
% WiNodesOrig = WiNodes
% 
% global hBar;
% hBar = hopCalc(DijkstraRoutingMatrix)
% 
% 
% DijkstraRoutingMatrix2 = zeros(MaxSwitchNumber,MaxSwitchNumber,MaxSwitchNumber);
% [ DijkstraRoutingMatrix2 ] = dijkstra_routing_information( DijkstraRoutingMatrix2 );
% 
% 
% hBarNew = hopCalc(DijkstraRoutingMatrix2)
% 
% global hBarArray;
% hBarArray(1) = hBar;
% 
% global hBarCounter;
% hBarCounter = 2;
% 
% 
% for i = 1:10000
% 
%     done = 0;
% 
%     while(done == 0)
% 
%         newWiNode = randi(64,1);
% 
%         % check to see if that node already exists
%         exists = 0;
% 
%         for j = 1:NumberWirelessNodes
%             if(newWiNode == WiNodes(j))
%                 exists = 1;
%             end
%         end
% 
%         correctDist = 0;
% 
%         if(exists == 0)
%             % check to see if the node is within 7mm of any other nodes;
%             correctDist = 1;
% 
%             for j = 1:NumberWirelessNodes
%                 otherNode = WiNodes(j);
% 
%                 if(otherNode ~= 0)
%                     distance = distanceCalc(newWiNode,otherNode);
% 
%                     if(distance < 7)
%                         correcDist = 0;
%                     end
%                 end
% 
%             end
% 
%         end
% 
%         alreadyLinked = 0;
% 
%         if(correctDist == 1)
% 
%             for j = 1:NumberWirelessNodes
%                 otherNode = WiNodes(j);
% 
%                 if(Connectivity(otherNode,newWiNode) == 1)
%                     alreadyLinked = 1;
%                 end
%             end
% 
%         end
% 
%         if(alreadyLinked == 0 && correctDist == 1 && exists == 0)
% 
%             done = 1;
% 
%         end
%     end
% 
%     newWiNode;
% 
%     replaceNode = randi(NumberWirelessNodes,1);
% 
%     oldNode = WiNodes(replaceNode);
% 
%     %removing the old links from the matrix
%     for j = 1:NumberWirelessNodes
% 
%         if(j ~= replaceNode)
%             Connectivity(WiNodes(j),oldNode,1) = -1;
%             Connectivity(oldNode,WiNodes(j),1) = -1;
%         end
%     end
% 
% 
%     WiNodes(replaceNode) = newWiNode;
% 
%     % adding the new links into the matrix
%     for j = 1:NumberWirelessNodes
% 
%         if(j ~= replaceNode)
%             Connectivity(WiNodes(j),newWiNode,1) = 1;
%             Connectivity(newWiNode,WiNodes(j),1) = 1;
%         end
% 
%     end
% 
%     DijkstraRoutingMatrix2 = zeros(MaxSwitchNumber,MaxSwitchNumber,MaxSwitchNumber);
%     [ DijkstraRoutingMatrix2 ] = dijkstra_routing_information( DijkstraRoutingMatrix2 );
% 
% 
%     hBarPrime = hopCalc(DijkstraRoutingMatrix2);
% 
%     if(hBarPrime < hBar)
%         counter = 0;
%         hBar = hBarPrime;
%         hBarArray(hBarCounter) = hBar;
%         hBarCounter = hBarCounter + 1;
%     else
% 
%         T = 100/i;
% 
%         prob = exp(-(hBarPrime - hBar)/T);
% 
%         randValue = rand(1);
% 
% 
%         if(randValue < prob)
%             counter = 0;
%             hBar = hBarPrime;
%             hBarArray(hBarCounter) = hBar;
%             hBarCounter = hBarCounter + 1;
% 
%         else
%             counter = counter + 1
% 
%             % if counter gets too high, break out of the for loop
% 
% 
%             %removing the old links from the matrix
%             for j = 1:NumberWirelessNodes
% 
%                 if(j ~= replaceNode)
%                     Connectivity(WiNodes(j),newWiNode,1) = -1;
%                     Connectivity(newWiNode,WiNodes(j),1) = -1;
%                 end
%             end
% 
%             WiNodes(replaceNode) = oldNode;
% 
%             % adding the new links into the matrix
%             for j = 1:NumberWirelessNodes
% 
%                 if(j ~= replaceNode)
%                     Connectivity(WiNodes(j),oldNode,1) = 1;
%                     Connectivity(oldNode,WiNodes(j),1) = 1;
%                 end
% 
%             end
% 
%             if(counter == 10)
%                 break;
%             end
%         end
%     end
% end
% 
% i
% WiNodes = sort(WiNodes)
% 
% 
% hBar
% plot(hBarArray);


% ------------------------------------------------------------------------%



% Wade Campney
% Commented out execution to test the SA section im working on



% Section setting up the connectivity matrix for now until the nodes are
% permenantly put in the excel matrix

% WiNodes = [ 2 18 24 26 29 31 32 41 42 53 58 64 ];
% WiNodes = [ 2 9 11 23 26 31 36 39 41 42 45 54 55 ];
% 
% % Setting up Connectivity matrix to include the wireless links
% 
% for i = 1:NumberWirelessNodes
% 
%     CurrentNode = WiNodes(i);
% 
%     for j = 1:NumberWirelessNodes
% 
%         tempNode = WiNodes(j);
% 
%         if(tempNode ~= CurrentNode)
%             Connectivity(tempNode,CurrentNode,1) = 2;
%             Connectivity(CurrentNode,tempNode,1) = 2;
%         end
%     end
% 
% end
% 
% DijkstraRoutingMatrix = zeros(MaxSwitchNumber,MaxSwitchNumber,MaxSwitchNumber);
% [ DijkstraRoutingMatrix ] = dijkstra_routing_information( DijkstraRoutingMatrix );
% 
% 
% hBarPrime = hopCalc(DijkstraRoutingMatrix)
% 
% xlswrite('WiNoCTest_13WI.xls', Connectivity(:,:,1));




for SimCycle = 1:NumberOfSimulationCycles

   % initializing temporary variables
InputVCBufferStatusTemp1 = InputVCBufferStatus;
InputVCBufferStatusTemp2 = InputVCBufferStatus;
InputVCBufferStatusTemp3 = InputVCBufferStatus;
OutputVCBufferStatusTemp1 = OutputVCBufferStatus;
OutputVCBufferStatusTemp2 = OutputVCBufferStatus;
OutputVCBufferStatusTemp3 = OutputVCBufferStatus;
CoreBufferStatusTemp1 = CoreBufferStatus;
CoreBufferStatusTemp2 = CoreBufferStatus;

[ CoreStatus, CoreBufferStatusTemp1, MsgStatus, InputVCBufferStatusTemp1 ] = flit_generate_all_cores( SimCycle, InjectionLoad, traffic, CoreStatus, MsgStatus, CoreBufferStatusTemp1, InputVCBufferStatusTemp1 );

[ InputVCBufferStatusTemp2, OutputVCBufferStatusTemp1, PortArbitStatus, CoreBufferStatusTemp2, VirtualArbitStatus, MsgStatus ] = intra_switch_moves( InputVCBufferStatusTemp2, OutputVCBufferStatusTemp1, PortArbitStatus, MsgStatus, CoreBufferStatusTemp2, VirtualArbitStatus );

[ InputVCBufferStatusTemp3, OutputVCBufferStatusTemp2, LinkArbitStatus, LinkStatus, MsgStatus, WiNodes, WirelessPortArbitStatus ] = inter_switch_moves( SimCycle, InputVCBufferStatusTemp3, OutputVCBufferStatusTemp2, LinkArbitStatus, LinkStatus, MsgStatus, WiNodes, WirelessPortArbitStatus );

[ OutputVCBufferStatusTemp3, AbsorbArbitStatus, MsgStatus, ThroughputPerCycle ] = flit_absorb( OutputVCBufferStatusTemp3, AbsorbArbitStatus, MsgStatus, ThroughputPerCycle );

% taking all input VC buffer status into a single variable
InputVCBufferStatusTempAll( :, :, :, :,1) = InputVCBufferStatusTemp1;
InputVCBufferStatusTempAll( :, :, :, :,2) = InputVCBufferStatusTemp2;
InputVCBufferStatusTempAll( :, :, :, :,3) = InputVCBufferStatusTemp3;

% taking all output VC buffer status into a single variable
OutputVCBufferStatusTempAll( :, :, :, :,1) = OutputVCBufferStatusTemp1;
OutputVCBufferStatusTempAll( :, :, :, :,2) = OutputVCBufferStatusTemp2;
OutputVCBufferStatusTempAll( :, :, :, :,3) = OutputVCBufferStatusTemp3;

% taking all core VC buffer status into a single variable
CoreBufferStatusTempAll( :, :,1) = CoreBufferStatusTemp1;
CoreBufferStatusTempAll( :, :,2) = CoreBufferStatusTemp2;

% updating all the changes in the current simulation cycle
[ InputVCBufferStatus, OutputVCBufferStatus, CoreBufferStatus ] = update( InputVCBufferStatusTempAll, OutputVCBufferStatusTempAll, CoreBufferStatusTempAll, InputVCBufferStatus, OutputVCBufferStatus, CoreBufferStatus );
if mod(SimCycle,25) == 0
SimCycle
end
% InputVCBufferStatus
% CoreBufferStatus
% OutputVCBufferStatus
% MsgStatus


% for calculating throughput
if SimCycle > ResetCycle
    NumberOfCyclesForThroughput = NumberOfCyclesForThroughput + 1;
end

end;
Throughput = ( NumberOfFlitsAbsorbed / NumberOfCyclesForThroughput ) / MaxCoreNumber;

%Throughput

% for calculating flits generated in input cores

Input = ( NumberOfFlitsGenerated / NumberOfCyclesForThroughput ) / MaxCoreNumber;

%Input

% for calculating latency
NumberOfMessages = size(MsgStatus,1); % number of messages generated by all the cores
count = 0;
LatencyOfAllMsg = [];
for MsgNo = 1:NumberOfMessages
    if ((MsgStatus(MsgNo,InjectCycle) < MsgStatus(MsgNo,AbsorbCycle)) && (MsgStatus(MsgNo,InjectCycle) > ResetCycle))
        count = count + 1;
        LatencyOfEachMsg = MsgStatus(MsgNo,AbsorbCycle) - MsgStatus(MsgNo,InjectCycle); % finding latency of each message
        LatencyOfAllMsg = [ LatencyOfAllMsg LatencyOfEachMsg ]; % taking latency of all messages into a single variable
    end

end

Latency = sum(LatencyOfAllMsg)/count; % calculating average latency of all messages considered

%Latency

% for energy calculation


% calculate link energy and link cycles based on link length
% use the link matrix with the extra links inserted for the wireless links
%LinkEnergyMatrix= xlsread('64core_Link_Distance.xls');
LinkCycleMatrix=xlsread('64core_Link_Distance.xls');


% Commented out the whole old section where the link energy was calculated
% based on the length of the links
%
% Value of 0.4 is used because almost every link will be 2mm so will use
% ~0.4 pj per link per bit

%Naseef Mansoor
global LengthTravelledInSingleCycle;
LengthTravelledInSingleCycle=2;
global FIFOEnergy;
FIFOEnergy=2.5*2;
% considering the buffers have 2 ports and energy per port= 2.5
%naseef mansoor end
TotalEnergy=0;
ValidMessageCount=0;
for iMsgNo= 1:size(MsgStatus,1)
    if((MsgEnergyStatus(iMsgNo,MsgLength,FlitAbsorbCycle)~=0)&&(MsgEnergyStatus(iMsgNo,1,FlitInjectCycle)>ResetCycle))
        ValidMessageCount=ValidMessageCount+1;
        SourceIndex=1;
        DestinationIndex=MaxCoreNumber+2;
        NextDestinationIndex=1;
        MessageLinkCycles=0;
        MessageLinkEnergy=0;
        MessageEnergy=0;
        while(DestinationIndex ~=MsgStatus(iMsgNo,Destination))
            % Naseef Mansoor
            if(MsgRoutingScheme(iMsgNo,2)==1)%wired transmission
                SourceIndex=DijkstraRoutingMatrixWired(MsgStatus(iMsgNo,Source),MsgStatus(iMsgNo,Destination),NextDestinationIndex);
                DestinationIndex=DijkstraRoutingMatrixWired(MsgStatus(iMsgNo,Source),MsgStatus(iMsgNo,Destination),(NextDestinationIndex+1));
             else
                SourceIndex=DijkstraRoutingMatrixWireless(MsgStatus(iMsgNo,Source),MsgStatus(iMsgNo,Destination),NextDestinationIndex);
                DestinationIndex=DijkstraRoutingMatrixWireless(MsgStatus(iMsgNo,Source),MsgStatus(iMsgNo,Destination),(NextDestinationIndex+1));
             end
             %Calculating the manhattan
             SourceX=mod(SourceIndex, TileDimension(XDim));
             if(SourceX==0)
                SourceX=TileDimension(XDim);
             end
             SourceY=ceil(SourceIndex/TileDimension(XDim));
             DestinationX=mod(DestinationIndex, TileDimension(XDim));
             if(DestinationX==0)
                DestinationX=TileDimension(XDim);
             end
             DestinationY=ceil(DestinationIndex/TileDimension(XDim));
             DistanceX=abs(SourceX-DestinationX)*TileSize(XDim)/TileDimension(XDim);
             DistanceY=abs(SourceY-DestinationY)*TileSize(YDim)/TileDimension(YDim);
%              ManhattanDistance=abs(SourceX-DestinationX)+abs(SourceY-DestinationY);
             Distance=DistanceX+DistanceY;
            %naseef mansoor end
            %SourceIndex=DijkstraRoutingMatrix(MsgStatus(MsgNo,Source),MsgStatus(MsgNo,Destination),NextDestinationIndex);
            %DestinationIndex=DijkstraRoutingMatrix(MsgStatus(MsgNo,Source),MsgStatus(MsgNo,Destination),(NextDestinationIndex+1));
            %MessageLinkCycles=MessageLinkCycles+LinkCycleMatrix(SourceIndex,DestinationIndex);
            foundWi1 = 0;
            foundWi2 = 0;
            % FoundWi1 and foundWi2 means this is a totally wireless
            % transmission
            for i = 1:NumberWirelessNodes
                if(SourceIndex == WiNodes(i,1))
                    % Receiving node
                    foundWi1 = 1;
                end
                if(DestinationIndex == WiNodes(i,1))
                    % Sending node
                    foundWi2 = 1;
                end
            end
            if(foundWi1 == 1 && foundWi2 == 1)
                %wifi1 = SourceIndex
                %wifi2 = DestinationIndex
                % 2.3 pj/bit for wireless transmissions
                %Naseef Mansoor
                MessageLinkEnergy = MessageLinkEnergy + (2.3*32);
                %naseef mansoor end
            else
                %wired1 = SourceIndex
                %wired2 = DestinationIndex
            %  0.4 pj per mm * 32 bits
                %MessageLinkEnergy = MessageLinkEnergy + (0.2*LinkData(SourceIndex,DestinationIndex,1)*32);
                %Naseef Mansoor
                MessageLinkEnergy = MessageLinkEnergy + ((32*0.2*Distance^2)/LengthTravelledInSingleCycle)+(Distance/LengthTravelledInSingleCycle-1)*FIFOEnergy;
                %multiply this with later part distance/2
                %naseef mansoor end
            end
        
            %MessageLinkEnergy=MessageLinkEnergy+LinkEnergyMatrix(SourceIndex,DestinationIndex);
            NextDestinationIndex=NextDestinationIndex+1;
        end
        FlitNo=1;
        while (FlitNo <= MsgLength)
           FlitCycles=MsgEnergyStatus(iMsgNo,FlitNo,FlitAbsorbCycle)-MsgEnergyStatus(iMsgNo,FlitNo,FlitInjectCycle);
            %MessageEnergy=MessageEnergy + MessageLinkEnergy + MsgStatus(MsgNo,SwitchCycles)*200 +  MsgStatus(MsgNo,BufferCycles)*80;
            % Each switch having 5 ports on average so 2.5*5=12.5
            %Naseef Mansoor
            MessageEnergy=MessageEnergy + MessageLinkEnergy;%+MsgStatus(iMsgNo,BufferCycles)*5;
            %naseef mansoor end
            FlitNo=FlitNo+1;
       end
        TotalEnergy=TotalEnergy+MessageEnergy + MsgStatus(iMsgNo,SwitchCycles)*12.5;
   end
end

%Naseef Mansoor 
% When token and data is blocked then add energy of the Msges that
% are blocked in the Wireless Path
if(DoNotBlockToken==0 && EnabledWirelessDataTransmission==0)
    for iMsgNo= 1:size(MsgStatus,1)
        if((MsgEnergyStatus(iMsgNo,MsgLength,FlitAbsorbCycle)==0)&&(MsgEnergyStatus(iMsgNo,1,FlitInjectCycle)>0)&& MsgRoutingScheme(iMsgNo,2)==2)% Msges injected after reset cycle and total Msg is not successfully transmitted.
            % Now need to check the path for iMsgNo if it has a wireless
            % communication or not.
            % First see if for this message we considered the wireless dijkstra
            % matrixor not
%              if(MsgRoutingScheme(iMsgNo,2)==2)
                HasWirelessInPath=check_wireless_communication_for_message(iMsgNo,MsgStatus);
                if(HasWirelessInPath==1)
    %                 So there is a wireless so consider this Msg
                      TotalEnergy=TotalEnergy+MsgStatus(iMsgNo,SwitchCycles)*12.5;
                end
%              end

        end
    end
end
%When token is blocked then consider the Msges Blocked in other wireless
%nodes not having the token
if(DoNotBlockToken==0 && EnabledWirelessDataTransmission==1)
    % Find Node having the token
    SwitchHavingTheToken=0;
    for iWiNodes=1:NumberWirelessNodes
        if(WiNodes(iWiNodes,3)==1) %if node have the token
            SwitchHavingTheToken=WiNodes(iWiNodes,1);
        end
    end
    for iMsgNo= 1:size(MsgStatus,1)
        if((MsgEnergyStatus(iMsgNo,MsgLength,FlitAbsorbCycle)==0)&&(MsgEnergyStatus(iMsgNo,1,FlitInjectCycle)>0)&& MsgRoutingScheme(iMsgNo,2)==2)% Msges injected after reset cycle and total Msg is not successfully transmitted.
            % Now need to check the path for iMsgNo if it has a wireless
            % communication or not.
%              if(MsgRoutingScheme(iMsgNo,2)==2)
                HasWirelessInPath=check_wireless_communication_for_message(iMsgNo,MsgStatus);
                if(HasWirelessInPath==1)
%                   Check if the wireless node having the token exists in
%                   the path or not need a function for this
    %               So there is a wireless and the switch that have the token is not in the path so consider this Msg
                    if(check_existance_of_wireless_node_in_wireless_path(iMsgNo,SwitchHavingTheToken,MsgStatus)==0)
                        TotalEnergy=TotalEnergy+MsgStatus(iMsgNo,SwitchCycles)*12.5;
                    end
                end
%              end

        end
    end
end
%naseef mansoor end
for i=1:NumberOfSimulationCycles
   ThroughputPerCycle(i,2) = ThroughputPerCycle(i,1)/MaxCoreNumber;
end
% Naseef Mansoor
% Calculate the throughput after blocking the token
TotalFlitsAfterBlockingToken=0;

ThroughputAfterBlockingToken=0;
for i=TokenPassingBlockCycle:NumberOfSimulationCycles
    TotalFlitsAfterBlockingToken=TotalFlitsAfterBlockingToken+ThroughputPerCycle(i,1);
end

ThroughputAfterBlockingToken=TotalFlitsAfterBlockingToken/MaxCoreNumber/(NumberOfSimulationCycles-TokenPassingBlockCycle);
% naseef mansoor end
plot(1:NumberOfSimulationCycles,ThroughputPerCycle(1:NumberOfSimulationCycles,2))


TotalEnergyPerMessage=TotalEnergy/ValidMessageCount
% For a single counter we have a energy of 16*1E-4pJ per cycle. The 'TotalEnergyPerMessageForTokenRecoveryScheme' gives the energy after we have added the token recovery mechanism in our system.
TotalEnergyPerMessageForTokenRecoveryScheme=(TotalEnergy+(16*10^-4)*NumberWirelessNodes*NumberOfSimulationCycles)/ValidMessageCount

avghop
Input
Throughput
ThroughputAfterBlockingToken
Latency
% MsgRoutingScheme






